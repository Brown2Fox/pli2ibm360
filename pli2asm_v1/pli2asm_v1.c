#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <stdlib.h>

/**
 * п р е д е л ь н ы е
 * размеры:
 */
#define MAXNISXTXT 50      /** - исходного текста;    */
#define NSINT     217      /** - табл.синтакс.правил; */
#define NCEL       20      /** - стека целей;         */
#define NDST      500      /** - стека достижений;    */
#define NVXOD      54      /** - табл.входов;         */
#define NSTROKA   200      /** - строки плотн.текста; */
#define NNETRM     17      /** - списка нетерминалов; */
#define MAXLTXT    50      /** - выходного текста;    */
#define MAXFORMT   30      /** - форматированного интерпретируемого  фрагмента исх.текста; */
#define NSYM      100      /** - таблицы имен и меток */

struct
{
    const char *outFileName;
    const char *inFileName;
    int verbosity;
} globalArgs;

void parse_args(int argc, char* argv[])
{
    const char *optString = "i:o:v";

    int opt = 0;

    globalArgs.inFileName = NULL;
    globalArgs.outFileName = NULL;
    globalArgs.verbosity = 0;

    while ((opt = getopt(argc, argv, optString)) != -1)
    {
        switch (opt)
        {
            case 'o':
                globalArgs.outFileName = optarg;
                break;

            case 'i':
                globalArgs.inFileName = optarg;
                break;

            case 'v':
                globalArgs.verbosity = 1;
                break;

            default:
                break;
        }
    }
}

/**
 * Б а з а  данных компилятора
 *
 * Б л о к  об'явления массива с исходным текстом
 */

int NISXTXT;                    /** длина массива */
char ISXTXT[MAXNISXTXT][80];    /** тело массива  */

/**
 * Б л о к  об'явления рабочих переменных
 */

int I1, I2, I3, I4;             /** счетчики циклов */
char PREDSYM = ' ';             /** последний обработанный символ в уплотненном исходном тексте */
char STROKA[NSTROKA];           /** место хранения уплотненного исходного текста */

/**
 * Текущие индексы соответственно в:
 */
int I; /** - уплотненном тексте; */
int J; /** - табл.грамм.правил;  */
int K; /** - стеке поставленных целей; */
int L; /** - стеке достигнутых целей;  */

/**
 * Шаблон для генерации
 * записи выходного файла
 * на АССЕМБЛЕРЕ IBM 370
 */
union
{
    char BUFCARD[80];
    struct
    {
        char METKA[8];
        char PROB1;
        char OPERAC[5];
        char PROB2;
        char OPERAND[12];
        char PROB3;
        char COMM[52];
    } _BUFCARD;
} ASM_CARD;

/**
 * Массив для хранения
 * выходного текста на
 * АССЕМБЛЕРЕ IBM 370
 */
char ASM_TEXT[MAXLTXT][80];
int ASM_TEXT_IDX;    /** индекс выходного массива*/

/**
 * Массив для форматирован-
 * ного  (в виде последова-
 * тельности 9-ти позицион-
 * ных строк-лексем) пред-
 * ставления интерпретиру-
 * емого фрагмента исходно-
 * го плотного текста
 */
char FORMT[MAXFORMT][9];
int IFORMT;          /** индекс форматированного массива */

/**
 * Б л о к  об'явления таблиц базы данных
 */

/**
 * Т а б л и ц а, используемая как магазин (стек) достижений
 */
struct
{
    char DST1[4];
    int DST2;
    int DST3;
    int DST4;
    int DST5;
} DST[NDST];

/**
 * Т а б л и ц а, используемая как магазин (стек) целей
 */
struct
{
    char CEL1[4];
    int CEL2;
    int CEL3;
} CEL[NCEL];

/**
 * Т а б л и ц а, синтаксических правил, записанных в форме распознавания,
 * сгруппированных в "кусты" и представленных в виде двухнапрвленного
 * списка с альтернативными разветвлениями
 */
struct
{
    int POSL;
    int PRED;
    char DER[4];
    int ALT;
} SINT[NSINT] =
/*   __________ _________ _______ _______ ______
    |  NN      :    посл : пред  :  дер  : альт |
    |__________:_________:_______:_______:______|                          */
        {{/*.    0     .*/     -1,  -1,  "***", -1},
/*                                               вход с символа - 0      */
         {/*.    1     .*/     2,   0,   "0  ", 0},
         {/*.    2     .*/     3,   1,   "CIF", 0},
         {/*.    3     .*/     0,   2,   "*  ", 0},
/*                                               вход с символа - 1      */
         {/*.    4     .*/     5,   0,   "1  ", 0},
         {/*.    5     .*/     6,   4,   "CIF", 7},
         {/*.    6     .*/     0,   5,   "*  ", 0},

         {/*.    7     .*/     8,   4,   "MAN", 0},
         {/*.    8     .*/     0,   7,   "*  ", 0},
/*                                               вход с символа - 2      */
         {/*.    9     .*/     10,  0,   "2  ", 0},
         {/*.   10     .*/     11,  9,   "CIF", 0},
         {/*.   11     .*/     0,   10,  "*  ", 0},
/*                                               вход с символа - 3      */
         {/*.   12     .*/     13,  0,   "3  ", 0},
         {/*.   13     .*/     14,  12,  "CIF", 0},
         {/*.   14     .*/     0,   13,  "*  ", 0},
/*                                               вход с символа - 4      */
         {/*.   15     .*/     16,  0,   "4  ", 0},
         {/*.   16     .*/     17,  15,  "CIF", 0},
         {/*.   17     .*/     0,   16,  "*  ", 0},
/*                                               вход с символа - 5      */
         {/*.   18     .*/     19,  0,   "5  ", 0},
         {/*.   19     .*/     20,  18,  "CIF", 0},
         {/*.   20     .*/     0,   19,  "*  ", 0},
/*                                               вход с символа - 6      */
         {/*.   21     .*/     22,  0,   "6  ", 0},
         {/*.   22     .*/     23,  21,  "CIF", 0},
         {/*.   23     .*/     0,   22,  "*  ", 0},
/*                                               вход с символа - 7      */
         {/*.   24     .*/     25,  0,   "7  ", 0},
         {/*.   25     .*/     26,  24,  "CIF", 0},
         {/*.   26     .*/     0,   25,  "*  ", 0},
/*                                               вход с символа - 8      */
         {/*.   27     .*/     28,  0,   "8  ", 0},
         {/*.   28     .*/     29,  27,  "CIF", 0},
         {/*.   29     .*/     0,   28,  "*  ", 0},
/*                                               вход с символа - 9      */
         {/*.   30     .*/     31,  0,   "9  ", 0},
         {/*.   31     .*/     32,  30,  "CIF", 0},
         {/*.   32     .*/     0,   31,  "*  ", 0},
/*                                               вход с символа - A      */
         {/*.   33     .*/     34,  0,   "A  ", 0},
         {/*.   34     .*/     35,  33,  "BUK", 0},
         {/*.   35     .*/     0,   34,  "*  ", 0},
/*                                               вход с символа - B      */
         {/*.   36     .*/     37,  0,   "B  ", 0},
         {/*.   37     .*/     38,  36,  "BUK", 0},
         {/*.   38     .*/     0,   37,  "*  ", 0},
/*                                               вход с символа - C      */
         {/*.   39     .*/     40,  0,   "C  ", 0},
         {/*.   40     .*/     41,  39,  "BUK", 201},
         {/*.   41     .*/     0,   40,  "*  ", 0},
/*                                               вход с символа - D      */
         {/*.   42     .*/     43,  0,   "D  ", 0},
         {/*.   43     .*/     44,  42,  "BUK", 45},
         {/*.   44     .*/     0,   43,  "*  ", 0},

         {/*.   45     .*/     46,  42,  "C  ", 0},
         {/*.   46     .*/     47,  45,  "L  ", 0},
         {/*.   47     .*/     48,  46,  "   ", 0},
         {/*.   48     .*/     49,  47,  "IDE", 0},
         {/*.   49     .*/     50,  48,  "   ", 0},
         {/*.   50     .*/     51,  49,  "B  ", 187},
         {/*.   51     .*/     52,  50,  "I  ", 0},
         {/*.   52     .*/     53,  51,  "N  ", 0},
         {/*.   53     .*/     54,  52,  "   ", 0},
         {/*.   54     .*/     55,  53,  "F  ", 0},
         {/*.   55     .*/     56,  54,  "I  ", 0},
         {/*.   56     .*/     57,  55,  "X  ", 0},
         {/*.   57     .*/     58,  56,  "E  ", 0},
         {/*.   58     .*/     59,  57,  "D  ", 0},
         {/*.   59     .*/     60,  58,  "(  ", 0},
         {/*.   60     .*/     61,  59,  "RZR", 0},
         {/*.   61     .*/     62,  60,  ")  ", 0},
         {/*.   62     .*/     63,  61,  ";  ", 65},
         {/*.   63     .*/     64,  62,  "ODC", 0},
         {/*.   64     .*/     65,  63,  "*  ", 0},

         {/*.   65     .*/     66,  61,  "I  ", 0},
         {/*.   66     .*/     67,  65,  "N  ", 0},
         {/*.   67     .*/     68,  66,  "I  ", 0},
         {/*.   68     .*/     69,  67,  "T  ", 0},
         {/*.   69     .*/     70,  68,  "(  ", 0},
         {/*.   70     .*/     71,  69,  "LIT", 0},
         {/*.   71     .*/     72,  70,  ")  ", 0},
         {/*.   72     .*/     73,  71,  ";  ", 0},
         {/*.   73     .*/     186, 72,  "ODC", 0},
/*                                               вход с символа - E      */
         {/*.   74     .*/     75,  0,   "E  ", 0},
         {/*.   75     .*/     76,  74,  "N  ", 82},
         {/*.   76     .*/     77,  75,  "D  ", 0},
         {/*.   77     .*/     78,  76,  "   ", 0},
         {/*.   78     .*/     79,  77,  "IPR", 0},
         {/*.   79     .*/     80,  78,  ";  ", 0},
         {/*.   80     .*/     81,  79,  "OEN", 0},
         {/*.   81     .*/     0,   80,  "*  ", 0},

         {/*.   82     .*/     83,  74,  "BUK", 0},
         {/*.   83     .*/     0,   82,  "*  ", 0},
/*                                               вход с символа - M      */
         {/*.   84     .*/     85,  0,   "M  ", 0},
         {/*.   85     .*/     86,  84,  "BUK", 0},
         {/*.   86     .*/     0,   85,  "*  ", 0},
/*                                               вход с символа - P      */
         {/*.   87     .*/     88,  0,   "P  ", 0},
         {/*.   88     .*/     89,  87,  "BUK", 0},
         {/*.   89     .*/     0,   88,  "*  ", 0},
/*                                               вход с символа - X      */
         {/*.   90     .*/     91,  0,   "X  ", 0},
         {/*.   91     .*/     92,  90,  "BUK", 0},
         {/*.   92     .*/     0,   91,  "*  ", 0},
/*                                               вход с символа - BUK    */
         {/*.   93     .*/     94,  0,   "BUK", 0},
         {/*.   94     .*/     95,  93,  "IDE", 0},
         {/*    95     .*/     0,   94,  "*  ", 0},
/*                                               вход с символа - IDE    */
         {/*.   96     .*/     97,  0,   "IDE", 0},
         {/*.   97     .*/     98,  96,  "BUK", 100},
         {/*.   98     .*/     99,  97,  "IDE", 0},
         {/*.   99     .*/     0,   98,  "*  ", 0},

         {/*.  100     .*/     101, 96,  "CIF", 103},
         {/*.  101     .*/     102, 100, "IDE", 0},
         {/*.  102     .*/     0,   101, "*  ", 0},

         {/*.  103     .*/     104, 96,  "IPE", 105},
         {/*.  104     .*/     0,   103, "*  ", 0},

         {/*.  105     .*/     106, 96,  "IPR", 0},
         {/*.  106     .*/     0,   105, "*  ", 0},
/*                                               вход с символа - +      */
         {/*.  107     .*/     108, 0,   "+  ", 0},
         {/*.  108     .*/     109, 107, "ZNK", 0},
         {/*.  109     .*/     0,   108, "*  ", 0},
/*                                               вход с символа - -      */
         {/*.  110     .*/     111, 0,   "-  ", 0},
         {/*.  111     .*/     112, 110, "ZNK", 0},
         {/*.  112     .*/     0,   111, "*  ", 0},
/*                                               вход с символа - IPR    */
         {/*.  113     .*/     114, 0,   "IPR", 0},
         {/*.  114     .*/     115, 113, ":  ", 0},
         {/*.  115     .*/     116, 114, "P  ", 0},
         {/*.  116     .*/     117, 115, "R  ", 0},
         {/*.  117     .*/     118, 116, "O  ", 0},
         {/*.  118     .*/     119, 117, "C  ", 0},
         {/*.  119     .*/     120, 118, "   ", 0},
         {/*.  120     .*/     121, 119, "O  ", 0},
         {/*.  121     .*/     122, 120, "P  ", 0},
         {/*.  122     .*/     123, 121, "T  ", 0},
         {/*.  123     .*/     124, 122, "I  ", 0},
         {/*.  124     .*/     125, 123, "O  ", 0},
         {/*.  125     .*/     126, 124, "N  ", 0},
         {/*.  126     .*/     127, 125, "S  ", 0},
         {/*.  127     .*/     128, 126, "(  ", 0},
         {/*.  128     .*/     129, 127, "M  ", 0},
         {/*.  129     .*/     130, 128, "A  ", 0},
         {/*.  130     .*/     131, 129, "I  ", 0},
         {/*.  131     .*/     132, 130, "N  ", 0},
         {/*.  132     .*/     133, 131, ")  ", 0},
         {/*.  133     .*/     134, 132, ";  ", 0},
         {/*.  134     .*/     135, 133, "OPR", 0},
         {/*.  135     .*/     0,   134, "*  ", 0},
/*                                                вход с символа - CIF    */
         {/*.  136     .*/     137, 0,   "CIF", 0},
         {/*.  137     .*/     138, 136, "RZR", 0},
         {/*.  138     .*/     0,   0,   "*  ", 0},
/*                                               вход с символа - RZR    */
         {/*.  139     .*/     140, 0,   "RZR", 0},
         {/*.  140     .*/     141, 139, "CIF", 0},
         {/*.  141     .*/     142, 140, "RZR", 0},
         {/*.  142     .*/     0,   141, "*  ", 0},
/*                                               вход с символа - MAN    */
         {/*.  143     .*/     144, 0,   "MAN", 0},
         {/*.  144     .*/     145, 143, "B  ", 147},
         {/*.  145     .*/     146, 144, "LIT", 0},
         {/*.  146     .*/     0,   145, "*  ", 0},

         {/*.  147     .*/     148, 143, "0  ", 150},
         {/*.  148     .*/     149, 147, "MAN", 0},
         {/*.  149     .*/     0,   148, "*  ", 0},

         {/*.  150     .*/     151, 143, "1  ", 0},
         {/*.  151     .*/     152, 150, "MAN", 0},
         {/*.  152     .*/     0,   151, "*  ", 0},
/*                                               вход с символа - IPE    */
         {/*.  153     .*/     154, 0,   "IPE", 0},
         {/*.  154     .*/     155, 153, "=  ", 159},
         {/*.  155     .*/     156, 154, "AVI", 0},
         {/*.  156     .*/     157, 155, ";  ", 0},
         {/*.  157     .*/     158, 156, "OPA", 0},
         {/*.  158     .*/     0,   157, "*  ", 0},

         {/*.  159     .*/     160, 153, "AVI", 0},
         {/*.  160     .*/     0,   159, "*  ", 0},
/*                                               вход с символа - LIT    */
         {/*.  161     .*/     162, 0,   "LIT", 0},
         {/*.  162     .*/     163, 161, "AVI", 0},
         {/*.  163     .*/     0,   162, "*  ", 0},
/*.                                              вход с символа - AVI    */
         {/*.  164     .*/     165, 0,   "AVI", 0},
         {/*.  165     .*/     166, 164, "ZNK", 0},
         {/*.  166     .*/     167, 165, "LIT", 168},
         {/*.  167     .*/     197, 166, "AVI", 0},

         {/*.  168     .*/     169, 165, "IPE", 0},
         {/*.  169     .*/     170, 168, "AVI", 0},
         {/*.  170     .*/     0,   169, "*  ", 0},
/*                                               вход с символа - OPR    */
         {/*.  171     .*/     172, 0,   "OPR", 0},
         {/*.  172     .*/     173, 171, "TEL", 0},
         {/*.  173     .*/     174, 172, "OEN", 0},
         {/*.  174     .*/     175, 173, "PRO", 0},
         {/*.  175     .*/     0,   174, "*  ", 0},
/*.                                              вход с символа - ODC    */
         {/*.  176     .*/     177, 0,   "ODC", 0},
         {/*.  177     .*/     178, 176, "TEL", 0},
         {/*.  178     .*/     0,   177, "*  ", 0},
/*.                                              вход с символа - TEL    */
         {/*.  179     .*/     180, 0,   "TEL", 0},
         {/*.  180     .*/     181, 179, "ODC", 183},
         {/*.  181     .*/     182, 180, "TEL", 0},
         {/*.  182     .*/     0,   181, "*  ", 0},

         {/*.  183     .*/     184, 179, "OPA", 211},
         {/*.  184     .*/     185, 183, "TEL", 0},
         {/*.  185     .*/     0,   184, "*  ", 0},

         {/*.  186     .*/     0,   73,  "*  ", 0},


         {/*.  187     .*/     188, 49,  "C  ", 0},
         {/*.  188     .*/     189, 187, "H  ", 0},
         {/*.  189     .*/     190, 188, "A  ", 0},
         {/*.  190     .*/     191, 189, "R  ", 0},
         {/*.  191     .*/     192, 190, "(  ", 0},
         {/*.  192     .*/     193, 191, "RZR", 0},
         {/*.  193     .*/     194, 192, ")  ", 0},
         {/*.  194     .*/     195, 193, ";  ", 0},
         {/*.  195     .*/     196, 194, "ODC", 0},
         {/*.  196     .*/     0,   195, "*  ", 0},

         {/*.  197     .*/     0,   166, "*  ", 0},

         {/*.  198     .*/     199, 0,   "*  ", 0},
         {/*.  199     .*/     200, 198, "ZNK", 0},
         {/*.  200     .*/     0,   199, "*  ", 0},

         {/*.  201     .*/     202, 0,   "A  ", 0},
         {/*.  202     .*/     203, 201, "L  ", 0},
         {/*.  203     .*/     204, 202, "L  ", 0},
         {/*.  204     .*/     205, 203, "   ", 0},
         {/*.  205     .*/     206, 204, "IDE", 0},
         {/*.  206     .*/     207, 205, "(  ", 0},
         {/*.  207     .*/     208, 206, ")  ", 0},
         {/*.  208     .*/     209, 207, ";  ", 0},
         {/*.  209     .*/     210, 208, "OCL", 0},
         {/*.  210     .*/     0,   209, "*  ", 0},

         {/*.  211     .*/     212, 179, "OCL", 0},
         {/*.  212     .*/     213, 211, "TEL", 0},
         {/*.  213     .*/     0,   212, "*  ", 0},
/*.                                              вход с символа - OCL    */
         {/*.  214     .*/     215, 0,   "OCL", 0},
         {/*.  215     .*/     216, 214, "TEL", 0},
         {/*.  216     .*/     0,   215, "*  ", 0}

        };

/**
 * Т а б л и ц а  входов в "кусты" ( корней )грамматических правил,
 * содержащая тип ( терминальность или нетерминальность ) корневых
 * символов
 */
struct
{
    char SYM[4];
    int VX;
    char TYP;
} VXOD[NVXOD] = {
//    _________ ___________ _____ ______
//   |  NN     |    символ | вход| тип  |
//   |_________|___________|_____|______|
      [0] =        {"AVI",   164,  'N'},
      [1] =        {"BUK",   93,   'N'},
      [2] =        {"CIF",   136,  'N'},
      [3] =        {"IDE",   96,   'N'},
      [4] =        {"IPE",   153,  'N'},
      [5] =        {"IPR",   113,  'N'},
      [6] =        {"LIT",   161,  'N'},
      [7] =        {"MAN",   143,  'N'},
      [8] =        {"ODC",   176,  'N'},
      [9] =        {"OEN",   0,    'N'},
     [10] =        {"OPA",   0,    'N'},
     [11] =        {"OPR",   171,  'N'},
     [12] =        {"PRO",   0,    'N'},
     [13] =        {"RZR",   139,  'N'},
     [14] =        {"OCL",   214,  'N'},
     [15] =        {"TEL",   179,  'N'},
     [16] =        {"ZNK",   0,    'N'},
     [17] =        {"A  ",   33,   'T'},
     [18] =        {"B  ",   36,   'T'},
     [19] =        {"C  ",   39,   'T'},
     [20] =        {"D  ",   42,   'T'},
     [21] =        {"E  ",   74,   'T'},
     [22] =        {"M  ",   84,   'T'},
     [23] =        {"P  ",   87,   'T'},
     [24] =        {"X  ",   90,   'T'},
     [25] =        {"0  ",   1,    'T'},
     [26] =        {"1  ",   4,    'T'},
     [27] =        {"2  ",   9,    'T'},
     [28] =        {"3  ",   12,   'T'},
     [29] =        {"4  ",   15,   'T'},
     [30] =        {"5  ",   18,   'T'},
     [31] =        {"6  ",   21,   'T'},
     [32] =        {"7  ",   24,   'T'},
     [33] =        {"8  ",   27,   'T'},
     [34] =        {"9  ",   30,   'T'},
     [35] =        {"+  ",   107,  'T'},
     [36] =        {"-  ",   110,  'T'},
     [37] =        {":  ",   0,    'T'},
     [38] =        {"I  ",   0,    'T'},
     [39] =        {"R  ",   0,    'T'},
     [40] =        {"N  ",   0,    'T'},
     [41] =        {"O  ",   0,    'T'},
     [42] =        {"T  ",   0,    'T'},
     [43] =        {"S  ",   0,    'T'},
     [44] =        {"(  ",   0,    'T'},
     [45] =        {")  ",   0,    'T'},
     [46] =        {"   ",   0,    'T'},
     [47] =        {";  ",   0,    'T'},
     [48] =        {"L  ",   0,    'T'},
     [49] =        {"F  ",   0,    'T'},
     [50] =        {"=  ",   0,    'T'},
     [51] =        {"H  ",   0,    'T'},
     [52] =        {"*  ",   198,  'T'},
};

/**
 * Т а б л и ц а  матрицы смежности - основа построения матрицы
 * преемников
 */
char TPR[NVXOD][NNETRM] = {
    //___________________________________________________________________________
    //       |AVI|BUK|CIF|IDE|IPE|IPR|LIT|MAN|ODC|OEN|OPA|OPR|PRO|RZR|OCL|TEL|ZNK|
    //_______|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|
    {/*AVI*/   1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*BUK*/   0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*CIF*/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0 },
    {/*IDE*/   0,  0,  0,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*IPE*/   1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0 },
    {/*IPR*/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0 },
    {/*LIT*/   1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*MAN*/   0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*ODC*/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0 },
    {/*OEN*/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*OPA*/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*OPR*/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0 },
    {/*PRO*/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*RZR*/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0 },
    {/*OCL*/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0 },
    {/*TEL*/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0 },
    {/*ZNK*/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  A*/   0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  B*/   0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  C*/   0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0 },
    {/*  D*/   0,  1,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  E*/   0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0 },
    {/*  M*/   0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  P*/   0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  X*/   0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  0*/   0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  1*/   0,  0,  1,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  2*/   0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  3*/   0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  4*/   0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  5*/   0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  6*/   0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  7*/   0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  8*/   0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  9*/   0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  +*/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1 },
    {/*  -*/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1 },
    {/*  :*/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  I*/   0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  R*/   0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  N*/   0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  O*/   0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  T*/   0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  S*/   0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  (*/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  )*/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  ;*/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*   */   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  L*/   0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  F*/   0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  =*/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  H*/   0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    {/*  **/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1 }
};

/**
 * Н А Ч А Л О  обработки исходного текста
 */

/**
 * п р о г р а м м а
 * уплотнения исходного текста путем
 * удаления "лишних"
 * пробелов, выполняющая
 * роль примитивного лек-
 * сического анализатора
 */
void compress_ISXTXT()
{
    I3 = 0;
    for (I1 = 0; I1 < NISXTXT; I1++)
    {
        for (I2 = 0; I2 < 80; I2++)
            if (ISXTXT[I1][I2] != '\0')
            {
                if (ISXTXT[I1][I2] == ' ' && (PREDSYM == ' ' || PREDSYM == ';' || PREDSYM == ')' || PREDSYM == ':' || PREDSYM == '('))
                {
                    PREDSYM = ISXTXT[I1][I2];
                    goto L2;
                }

                if ((ISXTXT[I1][I2] == '+' || ISXTXT[I1][I2] == '-' || ISXTXT[I1][I2] == '=' || ISXTXT[I1][I2] == '(' || ISXTXT[I1][I2] == ')' || ISXTXT[I1][I2] == '*') && PREDSYM == ' ')
                {
                    I3--;
                    goto L1;
                }


                if (ISXTXT[I1][I2] == ' ' && (PREDSYM == '+' || PREDSYM == '-' || PREDSYM == '=' || PREDSYM == '*'))
                {
                    goto L2;
                }

L1:
                PREDSYM = ISXTXT[I1][I2];
                STROKA[I3] = PREDSYM;
                I3++;

L2:
                continue;
            } else
                break;
    }
    STROKA[I3] = '\0';
}

/**
 * Построение таблицы
 * преемников из матрицы
 * смежности по алгоритму
 * Варшалла
 */
void build_TPR()
{
    for (I1 = 0; I1 < NNETRM; I1++)
    {
        for (I2 = 0; I2 < NVXOD; I2++)
        {
            if (TPR[I2][I1] & (I1 != I2))
            {
                for (I3 = 0; I3 < NNETRM; I3++)
                    TPR[I2][I3] |= TPR[I1][I3];
            }
        }
    }
}

/**
 * п р о г р а м м а
 * заполнения
 * ячейки стека поставлен-
 * ных целей
 */
void mcel(char *T1, int T2, int T3)
{

    strcpy(CEL[K].CEL1, T1);
    CEL[K].CEL2 = T2;
    CEL[K].CEL3 = T3;
    K++;
}

/**
 * п р о г р а м м а
 * заполнения
 * ячейки стека достигну-
 * тых целей
 */
void mdst(char *T1, int T2, int T3, int T4, int T5)
{
    strcpy(DST[L].DST1, T1);
    DST[L].DST2 = T2;
    DST[L].DST3 = T3;
    DST[L].DST4 = T4;
    DST[L].DST5 = T5;
    L++;
}


/**
 * п р о г р а м м а
 * вычисления порядкового
 * номера строки в табл.
 * VXOD, соответствующей
 * строке-параметру функц.
 */
int numb(const char *T1, int T2)
{
    for (I1 = 0; I1 < NVXOD; I1++)
    {
        if (!strncmp(T1, VXOD[I1].SYM, (size_t)T2))
        {
            if ((VXOD[I1].SYM[T2] == '\0') || (VXOD[I1].SYM[T2] == ' '))
            {
                return I1;
            }
        }
    }
    return -1;
}

void print_stacks(int N, int M)
{
    printf("CEL1, CEL2, CEL3\n");
    for (int i = 0; i < N; i++)
    {
        printf("%.4s, %i, %i\n", CEL[i].CEL1, CEL[i].CEL2, CEL[i].CEL3 );
    }
    printf("DST1, DST2, DST3, DST4, DST5\n");
    for (int i = 0; i < M; i++)
    {
        printf("%.4s, %i, %i, %i, %i\n", DST[i].DST1, DST[i].DST2, DST[i].DST3, DST[i].DST4, DST[i].DST5);
    }
}


/**
 * п р о г р а м м а
 * построения дерева
 * синтаксического разбора,
 * выполняющая роль синтак-
 * сического анализатора
 */
int sint_ANAL()
{

    I4 = 0;

    K = 0;
    L = 0;
    I = 0;
    J = 1;
    mcel("PRO", I, 999);

    if (TPR[numb(&STROKA[I], 1)][numb("PRO", 3)] == 0)
        return 1;

L2:

    J = VXOD[numb(&STROKA[I], 1)].VX;

L3:

    J = SINT[J].POSL;

L31:

    I++;

    if (I > I4)


        I4 = I;

    if (VXOD[numb(SINT[J].DER, 3)].TYP == 'T')
    {

        if (STROKA[I] == SINT[J].DER[0])
            goto L3;
        else
            goto L8;

    }

    if (SINT[SINT[J].POSL].DER[0] == '*')
    {
        I--;

        if (!strcmp(SINT[J].DER, CEL[K - 1].CEL1))
        {
            mdst(CEL[K - 1].CEL1, CEL[K - 1].CEL2, CEL[K - 1].CEL3, I, J);

            if (!strcmp(CEL[K - 1].CEL1, "PRO"))
                return 0;

            if (TPR[numb(CEL[K - 1].CEL1, 3)][numb(CEL[K - 1].CEL1, 3)])
            {
                J = VXOD[numb(CEL[K - 1].CEL1, 3)].VX;
                goto L3;
            }

L6:

            J = CEL[K - 1].CEL3;
            K--;
            goto L3;
        }

        if (!TPR[numb(SINT[J].DER, 3)][numb(CEL[K - 1].CEL1, 3)])
            goto L9;

        mdst(SINT[J].DER, CEL[K - 1].CEL2, 0, I, J);
        J = VXOD[numb(SINT[J].DER, 3)].VX;
        goto L3;
    }

    if (!TPR[numb(&STROKA[I], 1)][numb(SINT[J].DER, 3)])
        goto L8;

    mcel(SINT[J].DER, I, J);
    goto L2;

L8:

    I--;

L9:

    if (SINT[J].ALT != 0)
    {
        J = SINT[J].ALT;
        goto L31;
    }

    J = SINT[J].PRED;

    if ((VXOD[numb(SINT[J].DER, 3)].TYP == 'N') && (SINT[J].PRED > 0))
    {
        mcel(DST[L - 1].DST1, DST[L - 1].DST2, DST[L - 1].DST3);

L10:

        J = DST[L - 1].DST5;
        L--;
        goto L9;
    }

    if ((VXOD[numb(SINT[J].DER, 3)].TYP == 'N') && (SINT[J].PRED == 0))
    {
        if (!strcmp(CEL[K - 1].CEL1, DST[L - 1].DST1))
            goto L6;
        else
            goto L10;
    }

    if (SINT[J].PRED > 0)
        goto L8;

    J = CEL[K - 1].CEL3;
    K--;

    if (J == 999)
    {
        return 2;
    }

    else
        goto L8;

}



typedef enum SYMTYPE_T { UNDEFINED, PR_NAME, BIN, FUN } SYMTYPE;

/**
 * Таблица имен меток и
 * переменных, заполняемая
 * на первом проходе се-
 * мантического вычисления
 * и используемая на вто-
 * ром проходе семантичес-
 * кого вычисления
 */
struct
{
    char NAME[8];
    SYMTYPE TYPE;
    char RAZR[5];
    char INIT[50];
} SYM[NSYM];
int ISYM = 0; /** текущий индекс таблицы */


/**
 * п р о г р а м м а
 * перевода двоичной
 * константы из ASCIIz-ви-
 * да во внутреннее пред-
 * ставление типа long int
 */
long int VALUE(const char *s)
{
    long int S;
    int i;

    i = 0;
    S = 0;
    while (*(s + i) != 'B')
    {

        S <<= 1;
        if (*(s + i) == '1')
            S++;
        i++;
    }

    return (S);
}



/**
 * п р о г р а м м а
 * представления фрагмента
 * плотного текста в виде
 * массива 9-ти символьных
 * лексем
 */
void FORM()
{
    int i, j;

    for (IFORMT = 0; IFORMT < MAXFORMT; IFORMT++)
        memcpy(FORMT[IFORMT], "\0\0\0\0\0\0\0\0\0", 9);

    IFORMT = 0;
    j = DST[I2].DST2;

FORM1:

    for (i = j; i <= DST[I2].DST4 + 1; i++)
    {
        if (STROKA[i] == ':' || STROKA[i] == ' ' || STROKA[i] == '(' || STROKA[i] == ')' || STROKA[i] == ';' || STROKA[i] == '+' || STROKA[i] == '-' || STROKA[i] == '=' || STROKA[i] == '*')
        {
            FORMT[IFORMT][i - j] = '\0';
            IFORMT++;
            j = i + 1;
            goto FORM1;
        } else
            FORMT[IFORMT][i - j] = STROKA[i];

    }
}


/**
 * п р о г р а м м а
 * записи очередной сгене-
 * рированной записи вы-
 * ходного файла в массив
 * ASM_TEXT
 */
void ZKARD()
{

    memcpy(ASM_TEXT[ASM_TEXT_IDX++], ASM_CARD.BUFCARD, 80);

    for (int i = 0; i < 79; i++)
        ASM_CARD.BUFCARD[i] = ' ';
}


/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала AVI на пер-
 * вом проходе.   Здесь
 * AVI -   "арифм.выраж."
 */
int AVI1()
{
    return 0;
}



/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала BUK на пер-
 * вом проходе.   Здесь
 * BUK -   "буква"
 */
int BUK1()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала CIF на пер-
 * вом проходе.   Здесь
 * CIF -   "цифра"
 */
int CIF1()
{
    return 0;
}


/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала IDE на пер-
 * вом проходе.   Здесь
 * IDE -   "идентификатор"
 */
int IDE1()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала IPE на пер-
 * вом проходе.   Здесь
 * IPE - "имя переменной"
 */
int IPE1()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала IPR на пер-
 * вом проходе.   Здесь
 * IPR -   "имя программы"
 */
int IPR1()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала LIT на пер-
 * вом проходе.   Здесь
 * LIT -   "литерал"
 */
int LIT1()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала MAN на пер-
 * вом проходе.   Здесь
 * MAN -   "мантисса"
 */
int MAN1()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала ODC на пер-
 * вом проходе.   Здесь
 * ODC - "операт.ПЛ1- DCL"
 */
int ODC1()
{
    FORM();

    for (int i = 0; i < ISYM; i++)
    {
        if (!strcmp(SYM[i].NAME, FORMT[1]) && strlen(SYM[i].NAME) == strlen(FORMT[1]))
        {
            return 6;
        }
    }

    strcpy(SYM[ISYM].NAME, FORMT[1]);
    strcpy(SYM[ISYM].RAZR, FORMT[4]);


    if (!strcmp(FORMT[2], "BIN") && !strcmp(FORMT[3], "FIXED"))
    {
        SYM[ISYM].TYPE = BIN;
    }
    else
    {
        SYM[ISYM].TYPE = UNDEFINED;
        return 2;
    }

    if (!strcmp(FORMT[5], "INIT"))
    {
        strcpy(SYM[ISYM].INIT, FORMT[6]);
    }
    else
    {
        strcpy(SYM[ISYM].INIT, "0B");
    }

    ISYM++;
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала OEN на пер-
 * вом проходе.   Здесь
 * OEN - "операт.ПЛ1-END"
 */
int OEN1()
{
    FORM();

    for (int i = 0; i < ISYM; i++)
    {
        if (SYM[i].TYPE == PR_NAME)
        {
            if (!strcmp(SYM[i].NAME, FORMT[1]) && strlen(SYM[i].NAME) == strlen(FORMT[1]))
            {
                return 0;
            }
        }
    }

    return 1;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала OPA на пер-
 * вом проходе.   Здесь
 * OPA - "операт.присваи-
 * вания арифметический
 */
int OPA1()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала OPR на пер-
 * вом проходе.   Здесь
 * OPR - "операт.ПЛ1-PROC"
 */
int OPR1()
{
    FORM();

    strcpy(SYM[ISYM].NAME, FORMT[0]);
    SYM[ISYM].TYPE = PR_NAME;
    SYM[ISYM++].RAZR[0] = '\x0';

    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала PRO на пер-
 * вом проходе.   Здесь
 * PRO - "программа"
 */
int PRO1()
{
    return 0;
}


/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала RZR на пер-
 * вом проходе.   Здесь
 * RZR - "разрядность"
 */
int RZR1()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала TEL на пер-
 * вом проходе.   Здесь
 * TEL - "тело программы"
 */
int TEL1()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала ZNK на пер-
 * вом проходе.   Здесь
 * ZNK - "знак операции"
 */
int ZNK1()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала AVI на вто-
 * ром проходе.   Здесь
 * AVI -   "арифм.выраж."
 */
int AVI2()
{
    FORM();

    if (IFORMT == 1)
    {
        for (int i = 0; i < ISYM; i++)
        {
            if (!strcmp(SYM[i].NAME, FORMT[0]) && strlen(SYM[i].NAME) == strlen(FORMT[0]))
            {
                if (SYM[i].TYPE == BIN)
                {
                    if (strcmp(SYM[i].RAZR, "15") <= 0)
                        memcpy(ASM_CARD._BUFCARD.OPERAC, "LH", 2);
                    else
                        memcpy(ASM_CARD._BUFCARD.OPERAC, "L", 1);

                    strcpy(ASM_CARD._BUFCARD.OPERAND, "^ACR,");
                    strcat(ASM_CARD._BUFCARD.OPERAND, FORMT[0]);

                    ASM_CARD._BUFCARD.OPERAND[strlen(ASM_CARD._BUFCARD.OPERAND)] = ' ';
                    ZKARD();

                    return 0;
                }
                else
                {
                    return 3;
                }
            }
        }
        return 4;
    }
    else
    {
        for (int i = 0; i < ISYM; i++)
        {
            if (!strcmp(SYM[i].NAME, FORMT[IFORMT - 1]) && strlen(SYM[i].NAME) == strlen(FORMT[IFORMT - 1]))
            {
                if (SYM[i].TYPE == BIN)
                {
                    if (STROKA[DST[I2].DST4 - strlen(FORMT[IFORMT - 1])] == '+')
                    {
                        if (strcmp(SYM[i].RAZR, "15") <= 0)
                            memcpy(ASM_CARD._BUFCARD.OPERAC, "AH", 2);
                        else
                            memcpy(ASM_CARD._BUFCARD.OPERAC, "A", 1);
                    }
                    else
                    {
                        if (STROKA[DST[I2].DST4 - strlen(FORMT[IFORMT - 1])] == '-')
                        {
                            if (strcmp(SYM[i].RAZR, "15") <= 0)
                                memcpy(ASM_CARD._BUFCARD.OPERAC, "SH", 2);
                            else
                                memcpy(ASM_CARD._BUFCARD.OPERAC, "S", 1);
                        }
                        else
                        {
                            return 5;
                        }
                    }

                    strcpy(ASM_CARD._BUFCARD.OPERAND, "^ACR,");
                    strcat(ASM_CARD._BUFCARD.OPERAND, FORMT[IFORMT - 1]);
                    ASM_CARD._BUFCARD.OPERAND[strlen(ASM_CARD._BUFCARD.OPERAND)] = ' ';
                    ZKARD();

                    return 0;
                }
                else
                {
                    return 3;
                }
            }
        }
        return 4;
    }
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала BUK на вто-
 * ром проходе.   Здесь
 * BUK -   "буква"
 */
int BUK2()
{
    return 0;
}

/**
 *п р о г р а м м а
 * семантич. вычисления
 * нетерминала CIF на вто-
 * ром проходе.   Здесь
 * CIF -   "цифра"
 */
int CIF2()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала IDE на вто-
 * ром проходе.   Здесь
 * IDE -   "идентификатор"
 */
int IDE2()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала IPE на вто-
 * ром проходе.   Здесь
 * IPE - "имя переменной"
 */
int IPE2()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала IPR на вто-
 * ром проходе.   Здесь
 * IPR -   "имя программы"
 */
int IPR2()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала LIT на вто-
 * ром проходе.   Здесь
 * LIT -   "литерал"
 */
int LIT2()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала MAN на вто-
 * ром проходе.   Здесь
 * MAN -   "мантисса"
 */
int MAN2()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала ODC на вто-
 * ром проходе.   Здесь
 * ODC - "операт.ПЛ1- DCL"
 */
int ODC2()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала OEN на вто-
 * ром проходе.   Здесь
 * OEN - "операт.ПЛ1-END"
 * программа    формирует
 * эпилог ассемблеровского
 * эквивалента ПЛ1-прог-
 * раммы
 */
int OEN2()
{
    char RAB[20];
    FORM();

    memcpy(ASM_CARD._BUFCARD.OPERAC, "L", 1);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "^BASE,$PREB", 11);
    ZKARD();

    memcpy(ASM_CARD._BUFCARD.OPERAC, "BCR", 3);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "15,^RET", 7);
    ZKARD();

    memcpy(ASM_CARD._BUFCARD.METKA, "^BASE", 5);
    memcpy(ASM_CARD._BUFCARD.OPERAC, "EQU", 3);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "12", 2);
    ZKARD();

    memcpy(ASM_CARD._BUFCARD.METKA, "^SBASE", 6);
    memcpy(ASM_CARD._BUFCARD.OPERAC, "EQU", 3);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "13", 2);
    ZKARD();

    memcpy(ASM_CARD._BUFCARD.METKA, "^RET", 4);
    memcpy(ASM_CARD._BUFCARD.OPERAC, "EQU", 3);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "14", 2);
    ZKARD();

    memcpy(ASM_CARD._BUFCARD.METKA, "^TO", 3);
    memcpy(ASM_CARD._BUFCARD.OPERAC, "EQU", 3);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "15", 2);
    ZKARD();

    memcpy(ASM_CARD._BUFCARD.METKA, "^ACR", 4);
    memcpy(ASM_CARD._BUFCARD.OPERAC, "EQU", 3);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "3", 1);
    ZKARD();

    memcpy(ASM_CARD._BUFCARD.METKA, "$SWAP", 5);
    memcpy(ASM_CARD._BUFCARD.OPERAC, "DS", 2);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "F", 1);
    ZKARD();

    memcpy(ASM_CARD._BUFCARD.METKA, "$PREB", 5);
    memcpy(ASM_CARD._BUFCARD.OPERAC, "DS", 2);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "F", 1);
    ZKARD();

    memcpy(ASM_CARD._BUFCARD.METKA, "$S0", 3);
    memcpy(ASM_CARD._BUFCARD.OPERAC, "DS", 2);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "F", 1);
    ZKARD();




    for (int i = 0; i < ISYM; i++)
    {
        if (isalpha(SYM[i].NAME[0]))
        {
            if (SYM[i].TYPE == BIN)
            {
                strcpy(ASM_CARD._BUFCARD.METKA, SYM[i].NAME);
                ASM_CARD._BUFCARD.METKA[strlen(ASM_CARD._BUFCARD.METKA)] = ' ';
                memcpy(ASM_CARD._BUFCARD.OPERAC, "DC", 2);

                if (strcmp(SYM[i].RAZR, "15") <= 0)
                {
                    strcpy(ASM_CARD._BUFCARD.OPERAND, "H\'");
                }
                else
                {
                    strcpy(ASM_CARD._BUFCARD.OPERAND, "F\'");
                }
                strcat(ASM_CARD._BUFCARD.OPERAND, gcvt(VALUE(SYM[i].INIT), 10, &RAB[0]));
                ASM_CARD._BUFCARD.OPERAND[strlen(ASM_CARD._BUFCARD.OPERAND)] = '\'';
                ZKARD();
            }

            if (SYM[i].TYPE == FUN)
            {
                char OPERAND[4 + strlen(SYM[i].NAME)];
                strcpy(OPERAND, "A(");
                strcat(OPERAND, SYM[i].NAME);
                OPERAND[2 + strlen(SYM[i].NAME)] = ')';
                OPERAND[3 + strlen(SYM[i].NAME)] = 0;
                char LABEL[3 + strlen(SYM[i].NAME)];
                strcpy(LABEL, "$A");
                strcat(LABEL, SYM[i].NAME);

                memcpy(ASM_CARD._BUFCARD.METKA, LABEL, strlen(LABEL));
                memcpy(ASM_CARD._BUFCARD.OPERAC, "DC", 2);
                memcpy(ASM_CARD._BUFCARD.OPERAND, OPERAND, strlen(OPERAND));
                ZKARD();

                memcpy(ASM_CARD._BUFCARD.OPERAC, "EXTRN", 5);
                memcpy(ASM_CARD._BUFCARD.OPERAND, SYM[i].NAME, strlen(SYM[i].NAME));
                ZKARD();
            }
        }
    }

    memcpy(ASM_CARD._BUFCARD.OPERAC, "END", 3);

//    for (int i = 0; FORMT[1][i] != '\x0'; i++)
//    {
//        ASM_CARD._BUFCARD.OPERAND[i] = FORMT[1][i];
//    }
    ZKARD();

    return 0;
}



/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала OPA на вто-
 * ром проходе.   Здесь
 * OPA - "операт.присваи-
 * вания арифметический
 */
int OPA2()
{
    FORM();

    for (int i = 0; i < ISYM; i++)
    {
        if (!strcmp(SYM[i].NAME, FORMT[0]) && strlen(SYM[i].NAME) == strlen(FORMT[0]))
        {
            if (SYM[i].TYPE == BIN)
            {
                if (strcmp(SYM[i].RAZR, "15") <= 0)
                {
                    memcpy(ASM_CARD._BUFCARD.OPERAC, "STH", 3);
                }
                else
                {
                    memcpy(ASM_CARD._BUFCARD.OPERAC, "ST", 2);
                }

                strcpy(ASM_CARD._BUFCARD.OPERAND, "^ACR,");
                strcat(ASM_CARD._BUFCARD.OPERAND, FORMT[0]);

                ASM_CARD._BUFCARD.OPERAND[strlen(ASM_CARD._BUFCARD.OPERAND)] = ' ';

                ZKARD();

                return 0;
            }
            else
            {
                return 3;
            }
        }
    }
    return 4;
}



/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала OPR на вто-
 * ром проходе.   Здесь
 * OPR - "операт.ПЛ1-PROC"
 * программа    формирует
 * пролог ассемблеровского
 * эквивалента  исходной
 * ПЛ1-программы
 */
int OPR2()
{
    char i = 0;
    FORM();

    while (FORMT[0][i] != '\x0')
        ASM_CARD._BUFCARD.METKA[i++] = FORMT[0][i];

    memcpy(ASM_CARD._BUFCARD.OPERAC, "START", 5);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "0", 1);
    ZKARD();

    memcpy(ASM_CARD._BUFCARD.OPERAC, "BALR", 4);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "^BASE,0", 7);
    ZKARD();

    memcpy(ASM_CARD._BUFCARD.OPERAC, "USING", 5);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "*,^BASE", 7);
    ZKARD();

    memcpy(ASM_CARD._BUFCARD.OPERAC, "ST", 2);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "^SBASE,$PREB", 12);
    ZKARD();

    return 0;
}



/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала PRO на вто-
 * ром проходе.   Здесь
 * PRO - "программа"
 */
int PRO2()
{

    FILE *fp;

    if ((fp = fopen(globalArgs.outFileName, "w")) == NULL)
        return 7;
    else
        for (int i = 0; i < ASM_TEXT_IDX; i++ )
        {
            fprintf(fp, "%.80s|\n", ASM_TEXT[i]);
            printf("%.80s|\n", ASM_TEXT[i]);
        }

    fclose(fp);
    return 0;
}


/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала RZR на вто-
 * ром проходе.   Здесь
 * RZR - "разрядность"
 */
int RZR2()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала TEL на вто-
 * ром проходе.   Здесь
 * TEL - "тело программы"
 */
int TEL2()
{
    return 0;
}

/**
 * п р о г р а м м а
 * семантич. вычисления
 * нетерминала ZNK на вто-
 * ром проходе.   Здесь
 * ZNK - "знак операции"
 */
int ZNK2()
{
    return 0;
}


int OCL1()
{
    FORM();

    for (int i = 0; i < ISYM; i++)
    {
        if (!strcmp(SYM[i].NAME, FORMT[1]) && strlen(SYM[i].NAME) == strlen(FORMT[1]))
        {
            return 6;
        }
    }

    strcpy(SYM[ISYM].NAME, FORMT[1]);
    SYM[ISYM].TYPE = FUN;

    ISYM++;
    return 0;
}


int OCL2()
{
    FORM();

    memcpy(ASM_CARD._BUFCARD.OPERAC, "ST", 2);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "^BASE,$SWAP", 11);
    ZKARD();

    memcpy(ASM_CARD._BUFCARD.OPERAC, "L", 1);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "^SBASE,$SWAP", 12);
    ZKARD();

    memcpy(ASM_CARD._BUFCARD.OPERAC, "ST", 2);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "^RET,$S0", 8);
    ZKARD();

    char OPERAND[7 + strlen(FORMT[1])];
    strcpy(OPERAND, "^TO,$A");
    strcat(OPERAND, FORMT[1]);
    memcpy(ASM_CARD._BUFCARD.OPERAC, "L", 1);
    memcpy(ASM_CARD._BUFCARD.OPERAND, OPERAND, strlen(OPERAND));
    ZKARD();

    memcpy(ASM_CARD._BUFCARD.OPERAC, "BALR", 4);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "^RET,^TO", 8);
    ZKARD();

    memcpy(ASM_CARD._BUFCARD.OPERAC, "L", 1);
    memcpy(ASM_CARD._BUFCARD.OPERAND, "^RET,$S0", 8);
    ZKARD();

    return 0;
}

/**
 * п р о г р а м м а
 * управления абстрактной
 * ЭВМ  -  семантического
 * вычислителя, интерпре-
 * тирующего абстрактную
 * программу, сформирован-
 * ную синтаксическим ана-
 * лизатором в стеке дос-
 * тигнутых целей.
 * Суть алгоритма управле-
 * ния  в  последовательной
 * интерпретации строк сте-
 * ка достижений  в направ-
 * лении от дна к вершине.
 * При этом каждая строка
 * воспринимается как кома-
 * нда абстрактной ЭВМ со
 * следующими полями:
 * - DST.DST1 - код опера-
 * ции;
 * - DST.DST2 - левая гра-
 * ница интерпретируемого
 * фрагмента исх.текста;
 * - DST.DST4 -правая гра-
 * ница интерпретируемого
 * фрагмента исх.текста.
 */
int generate_code()
{
    int err_num;

    int (*FUN[NNETRM][2])() ={
                    [0] = {AVI1, AVI2},
                    [1] = {BUK1, BUK2},
                    [2] = {CIF1, CIF2},
                    [3] = {IDE1, IDE2},
                    [4] = {IPE1, IPE2},
                    [5] = {IPR1, IPR2},
                    [6] = {LIT1, LIT2},
                    [7] = {MAN1, MAN2},
                    [8] = {ODC1, ODC2},
                    [9] = {OEN1, OEN2},
                   [10] = {OPA1, OPA2},
                   [11] = {OPR1, OPR2},
                   [12] = {PRO1, PRO2},
                   [13] = {RZR1, RZR2},
                   [14] = {OCL1, OCL2},
                   [15] = {TEL1, TEL2},
                   [16] = {ZNK1, ZNK2}};

    /* организация первого    */
    /* прохода семантического */
    /* вычисления             */
    for (I2 = 0; I2 < L; I2++)
    {
        int idx = numb(DST[I2].DST1, 3);
        const int first = 0;
        if ((err_num = FUN[idx][first]()) != 0)
        {
            return err_num;
        }
    }

    /* организация второго    */
    /* прохода семантического */
    /* вычисления             */
    for (I2 = 0; I2 < L; I2++)
    {
        int idx = numb(DST[I2].DST1, 3);
        const int second = 1;
        if ((err_num = FUN[idx][second]()) != 0)
        {
            return (err_num);
        }
    }

    return 0;
}





int main(int argc, char* argv[])
{
    parse_args(argc, argv);

    FILE *fp = fopen(globalArgs.inFileName, "rb");
    if (fp  == NULL)
    {
        printf("%s: %s\n", "Something wrong with source code file (doesn't exist, busy by another process, etc)", globalArgs.inFileName);
        return -1;
    }

    for (NISXTXT = 0; NISXTXT <= MAXNISXTXT; NISXTXT++)
    {
        char trash[2];

        if (fread(ISXTXT[NISXTXT], sizeof(char), 80, fp) != 80 || fread(trash, sizeof(char), 2, fp) != 2)
        {
            if (feof(fp))
            {
                break;
            }
            else
            {
                printf("%s\n", "Error reading source file");
                return -1;
            }
        }

        printf("%.80s\n", ISXTXT[NISXTXT]);
    }

    fclose(fp);

    if (NISXTXT > MAXNISXTXT)
    {
        printf("%s\n","Переполнение буфера чтения исх.текста");
        return -1;
    }


    memset(ASM_CARD.BUFCARD, ' ', 80);

    compress_ISXTXT();


    build_TPR();

    if (sint_ANAL())
    {
        printf("Ошибка синтаксиса в исх.тексте -> %.10s\n", &STROKA[I4]);
        printf("Трансляция прервана\n");

        print_stacks(5, 45);

        return -1;
    }
    else
    {
        print_stacks(5, 45);

        switch (generate_code())
        {
            case 0:
                printf("%s\n", "Трансляция завершена успешно");
                return 0;

            case 1:
                printf("%s\n", "Несовпадение имени процедуры в прологе-эпилоге");
                break;

            case 2:
                printf("Недопустимый тип идентификатора: %s\n в исх.тексте -> %.20s\n", (char*)&FORMT[1], &STROKA[DST[I2].DST2]);
                break;

            case 3:
                printf("Недопустимый тип идентификатора: %s\n в исх.тексте -> %.20s\n", (char*)&FORMT[IFORMT - 1], &STROKA[DST[I2].DST2]);
                break;

            case 4:
                printf("Неопределенный идентификатор: %s\n в исх.тексте -> %.20s\n", (char*)&FORMT[IFORMT - 1], &STROKA[DST[I2].DST2]);
                break;

            case 5:
                printf("Недопустимая операция: %c\n  в исх.тексте -> %.20s\n", STROKA[DST[I2].DST4 - strlen(FORMT[IFORMT - 1])], &STROKA[DST[I2].DST2]);
                break;

            case 6:
                printf("Повторное объявление идентификатора: %s\n в исх.тексте -> %.20s\n", (char*)&FORMT[1], &STROKA[DST[I2].DST2]);
                break;

            default:
                break;
        }

    }

    printf("%s\n", "Трансляция прервана");

    return 0;
}
